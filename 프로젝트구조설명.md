# 🏗️ KMP 클린 아키텍처 프로젝트 구조 설명 (리팩토링 완료!)

> "왜 이렇게 복잡하게 나눠놨지?" 🤔  
> → 사실은 더 **단순하고 관리하기 쉽게** 만들기 위해서입니다!  
> ✨ **이제 더욱 직관적으로 개선되었습니다!**

## 🎉 새로운 직관적 구조

**기존 → 개선된 구조**

```
❌ 기존 (헷갈리는 구조)
├── composeApp/     ← 이름이 애매함
├── domain/         ← 흩어져 있음  
├── data/
├── presentation/
└── iosApp/

✅ 개선된 구조 (직관적!)
├── 📱 app/              ← 명확한 앱 이름
├── 📦 modules/          ← 클린아키텍처 모듈 그룹화
│   ├── 🏗️ domain/        ← 비즈니스 로직
│   ├── 🧱 data/          ← 데이터 관리  
│   └── 🎨 presentation/   ← UI 화면
└── 🍎 iosOnlyMain/      ← iOS 전용임이 명확
```

## 🤔 KMP 모듈 구조 이해하기 (중요!)

### 📱 "iosOnlyMain은 있는데 androidApp은 왜 없어요?"

**좋은 질문이에요!** KMP의 플랫폼별 구조를 이해해봅시다:

```
KMP 프로젝트/
├── 📱 app/                  ← 🎯 실제로는 3개 앱을 만드는 "멀티 앱 팩토리"
│   ├── androidTarget()       ← 🤖 안드로이드 앱이 여기 있어요!
│   ├── iosTarget()          ← 🍎 iOS Framework 생성
│   └── wasmJs()             ← 🌐 웹 앱
│
├── 📦 modules/              ← 클린아키텍처 모듈들이 깔끔하게 정리됨
│   ├── 🏗️ domain/
│   ├── 🧱 data/
│   └── 🎨 presentation/
│
└── 🍎 iosOnlyMain/          ← iOS만의 특별한 "래퍼 앱"
    └── SwiftUI 코드          ← iOS Framework를 감싸는 껍데기
```

### 🔍 실제 소스 구조

```
app/src/
├── 🔄 commonMain/        ← 모든 플랫폼 공통 (우리가 만든 클린아키텍처)
├── 🤖 androidMain/       ← 안드로이드 앱 진입점 (MainActivity.kt)
├── 🍎 iosMain/           ← iOS 연결 코드 (거의 비어있음)
└── 🌐 wasmJsMain/        ← 웹 앱 진입점 (main.kt)
```

### 🏗️ 빌드 결과물

```
🤖 Android: app → app-debug.apk (바로 설치 가능!)
🍎 iOS: app → Framework + iosOnlyMain → KotlinProject.app 
🌐 Web: app → app.js (브라우저 실행)
```

**왜 iOS만 2단계인가요?**

- 🤖 **Android**: Compose가 네이티브라 바로 APK 생성
- 🍎 **iOS**: Apple 규정상 SwiftUI 래퍼 필요 + App Store 제출용 Xcode 프로젝트 필요
- 🌐 **Web**: 바로 JS 생성 가능

## 🏠 집짓기로 이해하는 프로젝트 구조

우리 프로젝트를 **집을 짓는 것**에 비유해보면:

```
🏗️ 기존 방식 (모든 게 섞여있음)
📦 하나의 큰 방
    ├── 침실 + 화장실 + 주방 + 거실이 모두 한 공간 😵
    └── 뭔가 고치려면 전체가 영향받음...

vs 

🏗️ 클린 아키텍처 (역할별 분리) + 정리된 구조
📦 modules/              ← 📁 클린아키텍처 전용 서랍
   ├── 🏗️ domain/       ← 건축 설계도 (비즈니스 룰)
   ├── 🧱 data/         ← 자재 창고 (데이터 관리)
   └── 🎨 presentation/ ← 인테리어 (사용자가 보는 화면)
📱 app/                 ← 🚪 현관문 (앱 시작점) + 🏭 멀티플랫폼 팩토리
🍎 iosOnlyMain/         ← iOS 전용 출입구
```

## 📁 각 폴더가 하는 일

### 📱 `app/` - 멀티플랫폼 앱 팩토리

**"하나의 코드로 3개 플랫폼 앱을 만드는"** 마법의 공장

```kotlin
// 실제 build.gradle.kts 설정
kotlin {
    androidTarget()    // 안드로이드 APK 생성
    iosX64()          // iOS 시뮬레이터용
    iosArm64()        // iPhone용  
    wasmJs()          // 웹 브라우저용
}
```

**app의 역할:**

- 🎯 **모든 플랫폼 앱의 진입점**
- 🔧 **클린아키텍처 모듈들 조합** (DI 설정)
- 📱 **플랫폼별 빌드 설정**

### 📦 `modules/` - 클린아키텍처 전용 폴더

**관련 모듈들을 깔끔하게 정리한 서랍**

#### 🏗️ `modules/domain/` - 건축 설계도

**"앱이 뭘 해야 하는지"를 정의하는 곳**

```kotlin
// 예시: 사용자가 어떻게 생겼는지 정의
data class User(
    val name: String,
    val email: String
)

// 예시: "사용자 목록을 가져와라"라는 명령어 정의
class GetUsersUseCase {
    fun execute() = "사용자들을 가져와!"
}
```

**왜 중요한가?**

- 🚫 **외부 의존성 없음** (안드로이드, iOS 상관없이 동작)
- 🧠 **비즈니스 로직만** 들어있음
- ✅ **테스트하기 쉬움**

#### 🧱 `modules/data/` - 자재 창고

**"실제로 데이터를 어디서 가져올지"를 구현하는 곳**

```kotlin
// 예시: 인터넷에서 사용자 정보 가져오기
class UserRemoteDataSource {
    fun getUsers() = "서버에서 사용자 데이터 가져옴"
}

// 예시: domain의 명령을 실제로 실행
class UserRepositoryImpl : UserRepository {
    fun getUsers() = remoteDataSource.getUsers()
}
```

**왜 중요한가?**

- 🌐 **네트워크, 데이터베이스** 처리
- 🔄 **데이터 변환** (서버 ↔ 앱 형식)
- 🎯 **domain의 지시사항을 실제로 실행**

#### 🎨 `modules/presentation/` - 인테리어

**"사용자가 보는 화면"을 만드는 곳**

```kotlin
// 예시: 화면에 표시할 상태 관리
class UserViewModel {
    fun loadUsers() = "사용자 목록을 화면에 보여줘"
}

// 예시: 실제 화면 구성
@Composable
fun UserListScreen() {
    // 사용자 목록을 예쁘게 화면에 표시
}
```

**왜 중요한가?**

- 📱 **UI/UX** 담당
- 🔄 **사용자 입력** 처리
- 🎭 **화면 상태** 관리

### 🍎 `iosOnlyMain/` - iOS 전용 래퍼

**iOS만의 특별한 SwiftUI 앱**

- iOS App Store 제출용
- SwiftUI로 우리 앱 프레임워크를 감싸는 역할

## 🔗 의존성 관계 (누가 누구를 알고 있나?)

```
📱 app              ← 모든 걸 알고 있음 (조립담당)
     ↙     ↘
🎨 presentation   🧱 data
     ↘         ↙
    🏗️ domain     ← 아무것도 모름 (순수 비즈니스 로직)
```

### 🤔 왜 이런 관계인가요?

1. **domain**은 **"순수한 비즈니스 로직"**만 가져야 해서 아무것도 모름
2. **data**와 **presentation**은 domain의 규칙을 따름
3. **app**이 모든 걸 연결해서 완성된 앱을 만듦

## 🎯 실제 동작 흐름

사용자가 "사용자 목록 보기" 버튼을 눌렀을 때:

```
1. 🎨 presentation: "사용자 목록 보여달라고 해야지"
   ↓
2. 🏗️ domain: "사용자 목록 가져오기 비즈니스 로직 실행"
   ↓  
3. 🧱 data: "서버에서 실제 데이터 가져옴"
   ↓
4. 🎨 presentation: "받은 데이터를 예쁘게 화면에 표시"
```

## ✅ 리팩토링 후 이점

### 🧹 **더욱 깔끔한 구조**

- **modules/ 폴더**로 클린아키텍처 모듈들이 깔끔하게 정리
- **app/**이라는 명확한 이름으로 앱의 역할이 분명해짐
- **iosOnlyMain/**으로 iOS 전용임이 명확해짐

### 🔧 **유지보수가 쉬워요**

- UI가 바뀌어도 비즈니스 로직은 그대로
- 서버 API가 바뀌어도 UI는 그대로
- 각자 역할이 명확해서 버그 찾기 쉬움

### 🧪 **테스트가 쉬워요**

```kotlin
// domain만 따로 테스트 가능
@Test
fun `사용자 목록 가져오기 테스트`() {
    // UI나 네트워크 없이도 비즈니스 로직 테스트 가능!
}
```

### 🚀 **새 기능 추가가 쉬워요**

새로운 기능 (예: 게시물 관리)을 추가한다면:

```
1. 🏗️ modules/domain: Post 모델, PostUseCase 추가
2. 🧱 modules/data: PostRepository 구현
3. 🎨 modules/presentation: PostScreen 추가  
4. 📱 app: 연결
```

각 단계가 독립적이고 위치도 명확해서 실수할 확률이 더욱 낮아요!

## 🎮 개선된 실제 파일들 위치

```
📁 프로젝트/
├── 📦 modules/                           ← 클린아키텍처 모듈들이 깔끔하게 정리!
│   ├── 🏗️ domain/src/commonMain/kotlin/
│   │   ├── model/User.kt                ← 사용자가 뭔지 정의
│   │   ├── usecase/GetUsersUseCase.kt   ← 사용자 목록 가져오기 로직
│   │   └── repository/UserRepository.kt ← 데이터 가져오기 규칙
│   │
│   ├── 🧱 data/src/commonMain/kotlin/  
│   │   ├── dto/UserDto.kt               ← 서버와 주고받는 데이터 형식
│   │   ├── datasource/UserRemoteDataSource.kt ← 실제 서버 통신
│   │   └── repository/UserRepositoryImpl.kt ← 규칙의 실제 구현
│   │
│   └── 🎨 presentation/src/commonMain/kotlin/
│       ├── viewmodel/UserViewModel.kt   ← 화면 상태 관리
│       └── screen/UserListScreen.kt     ← 실제 화면
│
├── 📱 app/src/                          ← 🏭 멀티플랫폼 앱 팩토리 (이름이 명확!)
│   ├── commonMain/kotlin/App.kt         ← 모든 걸 연결하는 시작점
│   ├── androidMain/kotlin/MainActivity.kt ← 🤖 안드로이드 진입점
│   ├── iosMain/kotlin/MainViewController.kt ← 🍎 iOS 연결부
│   └── wasmJsMain/kotlin/main.kt        ← 🌐 웹 진입점
│
└── 🍎 iosOnlyMain/                      ← iOS 전용임이 명확!
    └── ContentView.swift                ← app Framework 사용
```

## 🚀 결론

**리팩토링 후 더욱 좋아진 점들:**

- ✅ **각자 역할이 더욱 명확**해서 개발하기 쉬움
- ✅ **테스트하기 쉬움**
- ✅ **유지보수가 편함**
- ✅ **팀 개발에 좋음** (modules 폴더로 명확한 분리)
- ✅ **🎯 하나의 코드로 3개 플랫폼** (Android + iOS + Web)
- ✨ **직관적인 폴더 이름과 구조**
- 🧹 **깔끔하게 정리된 모듈들**

**"이제 정말로 단순하고 깔끔한 구조가 완성되었습니다!"** 🎉

---
*더 이해하기 쉬워졌나요? 궁금한 점이 있으면 언제든 물어보세요! 😊*